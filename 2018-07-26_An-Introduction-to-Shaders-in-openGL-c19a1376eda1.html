<!DOCTYPE html><html><head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-175038637-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      
      gtag('config', 'UA-175038637-1');
    </script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>An Introduction to Shaders in openGL</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">An Introduction to Shaders in openGL</h1>
</header>
<section data-field="subtitle" class="p-summary">
Recently I became interested in graphics programming, specifically shaders. Alot of tutorials are very high level and don’t try to teach…
</section>
<section data-field="body" class="e-content">
<section name="aae3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e605" id="e605" class="graf graf--h3 graf--leading graf--title">An Introduction to Shaders in openGL</h3><p name="3e3f" id="3e3f" class="graf graf--p graf-after--h3">Recently I became interested in graphics programming, specifically shaders. Alot of tutorials are very high level and don’t try to teach you what’s happening under the hood. I wanted to understand things happening under the hood. Below is my annotation for a set of<a href="http://pyopengl.sourceforge.net/context/tutorials/index.html" data-href="http://pyopengl.sourceforge.net/context/tutorials/index.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> openGL tutorials</a>.</p><p name="a49e" id="a49e" class="graf graf--p graf-after--p">1 — Choose your language, platform.</p><p name="073f" id="073f" class="graf graf--p graf-after--p">I chose <a href="http://opengl.org" data-href="http://opengl.org" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">openGL</a>, specifically <a href="http://pyopengl.sourceforge.net" data-href="http://pyopengl.sourceforge.net" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">PyOpenGL</a>. openGL is an open standard maintained by many companies through <a href="https://www.khronos.org/" data-href="https://www.khronos.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Khronos</a>. It’s very flexible and runs on basically every system. Other choices would be DirectX 12 (the closed source microsoft windows graphics library) and Vulkan a more powerful but lower level successor to openGL (open source, made by Khronos group).</p><p name="06d8" id="06d8" class="graf graf--p graf-after--p">2 — Run through starter tutorials.</p><p name="5c5e" id="5c5e" class="graf graf--p graf-after--p">There is a <a href="http://pyopengl.sourceforge.net/context/tutorials/" data-href="http://pyopengl.sourceforge.net/context/tutorials/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">tutorial series</a> “Introduction to Shaders (Lighting)” on the pyopengl website that gives good practice. I didn’t understand everything at first but was able to start understanding concepts after forcing myself through a few tutorials. My process was to code up 2–3 tutorials without trying too hard to understand what I was doing. Then go back the next day and try to understand every line of code by typing out summaries at the the top of each script.</p><p name="5acf" id="5acf" class="graf graf--p graf-after--p">3 — Guidelines for these tutorials</p><p name="2a0e" id="2a0e" class="graf graf--p graf-after--p">The tutorials don’t work well with python 3 (you can’t install OpenGLContext). So you need to setup an environment with python 2 and then install opengl stuff in that environment:</p><figure name="bae7" id="bae7" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yvan/c27c0c75b22f4754bc074191d1daa722.js"></script></figure><p name="f358" id="f358" class="graf graf--p graf-after--figure">The following are my takeaways from each tutorial. Keep in mind that these are not intended to substitute for the tutorials but rather fill in information I thought was missing or needed clarification; they are intended to be done alongside the original tutorials.</p><h4 name="d7ef" id="d7ef" class="graf graf--h4 graf-after--p">Tutorial 1</h4><p name="ac8a" id="ac8a" class="graf graf--p graf-after--h4">The point of this tutorial is to get started. You need two shaders, a vertex shader and a fragment shader. The vertex shaders processes each point/vertex that you pass in and returns position values for that point. The fragment shader returns colors for all the pixels that are bounded by 3 vertices. In otherwords it connects 3 vertices and returns colors for all the points in between them. With openGL we define vertices and then build all the objects we want to draw on screen using triangles. A vbo is an array that holds data that will go to your GPU. In openGL you define an array locally with numpy and then you bind it into the gpu and then you use pointers like<code class="markup--code markup--p-code">glVertexPointerf</code>to point at the data in your vbo. When you call the draw method it looks for the vertex pointers you have created, reads the points in order, and draws them in batches of 3 as triangles on your screen. Here we draw a simple set of triangles and color them green.</p><p name="956f" id="956f" class="graf graf--p graf-after--p"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial1.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial1.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial1.py</a></p><h4 name="bb3d" id="bb3d" class="graf graf--h4 graf-after--p">Tutorial 2</h4><p name="f23f" id="f23f" class="graf graf--p graf-after--h4">The point of this tutorial is to expand on the previous one by adding more colors to the fragment. To do this we will set a vertex color in our vertex shader and then pass this value into the fragment shader. The fragment shader automatically looks at the colors in each the vertices it gets for a fragment (each fragment should get 3 vertices because we draw triangles on the screen) and blends them for the fragment it is returning. This funky behavior is called interpolation and I think opengl uses <a href="https://en.wikipedia.org/wiki/Gouraud_shading" data-href="https://en.wikipedia.org/wiki/Gouraud_shading" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Goraud Shading by default</a> to do it. The <a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/varying.php" data-href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/varying.php" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">varying </em>type values</a> allow use to set values in the vertex shader and then access the result of interpolation in the fragment shader. In other words anything you set as <em class="markup--em markup--p-em">varying</em> in the vertex shader will be interpolated by default in the fragment shader. I want to emphasize how weird this is because it confused me at first. The best way to think about the fragment shader seems to be to envision that is receives points from the vertex shader in batches of N (N=3, points of a triangle here) and then takes each point that is in between the batch of 3 (so every point inside the triangle) and runs it through your fragment shader on that point, determining which color blend of the original 3 it should use for that point. The fragment shader is called a lot so it is fairly important that it be efficient. The vertex shader is only called, say 9 times (since we have 3 fragments, 3 times per fragment) and so we’d rather put computation in the vertex shader and let opengl work its interpolation magic. If successful it should look like this:</p><figure name="3989" id="3989" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 299px; max-height: 326px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 109.00000000000001%;"></div><img class="graf-image" data-image-id="1*d-mImnbT4xYVAq7C9JeglA.png" data-width="299" data-height="326" src="img/1_d-mImnbT4xYVAq7C9JeglA.png"></div></figure><p name="a221" id="a221" class="graf graf--p graf-after--figure"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial2.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial2.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial2.py</a></p><h4 name="1d70" id="1d70" class="graf graf--h4 graf-after--p">Tutorial 3</h4><p name="b9af" id="b9af" class="graf graf--p graf-after--h4">The point of this tutorial is to introduce <a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" data-href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">uniform</em> values</a>. Like varying value it can be used to share information between the vertex and fragment shaders but uniform values don’t get interpolated. Uniform values do not change for a whole rendering pass; they may change on the next rendering pass. So in this tutorial we setup a uniform fog value and based on the distance you are viewing the triangles from the fog gets thicker (further away) or thinner (if you are very close). Importantly I have changed my fog to be black, instead of white like the original tutorial, to match my black openglcontext background.</p><p name="6502" id="6502" class="graf graf--p graf-after--p"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial3.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial3.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial3.py</a></p><h4 name="34e6" id="34e6" class="graf graf--h4 graf-after--p">Tutorial 4</h4><p name="763c" id="763c" class="graf graf--p graf-after--h4">The point of this tutorial is to introduce<em class="markup--em markup--p-em"> </em><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/attributes.php" data-href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/attributes.php" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">attribute</em> values</a>. Here we learn that the <code class="markup--code markup--p-code">glVertexPointer</code>and<code class="markup--code markup--p-code">glColorPointer</code>are legacy opengl. Instead in modern opengl we use<code class="markup--code markup--p-code">glVertexAttribPointer</code>which can point to arbitrary data. In this tutorial we create an animation where every frame of the animation calls a function named OnTimerFraction. Inside this function we set a fraction (called the tween) that tells us the proportion in which to combine 2 points. In our shader we then use the <em class="markup--em markup--p-em">mix</em> function to find a point between the point and a secondary position. If you do it correctly it will look like this, finding some intermediary point for every frame of the animation between two stated positions:</p><figure name="12fc" id="12fc" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 300px; max-height: 328px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 109.3%;"></div><img class="graf-image" data-image-id="1*Owi1lZ6CW8hhejtgFLl2VQ.gif" data-width="300" data-height="328" src="img/1_Owi1lZ6CW8hhejtgFLl2VQ.gif"></div></figure><p name="7751" id="7751" class="graf graf--p graf-after--figure"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial4.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial4.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial4.py</a></p><h4 name="d59d" id="d59d" class="graf graf--h4 graf-after--p">Tutorial 5</h4><p name="62f0" id="62f0" class="graf graf--p graf-after--h4">The point of this tutorial is start examining lighting (an entire graphics subfield in itself). In this tutorial we are going to create an object in space and then apply ambient and diffuse lighting to the object. <a href="https://unity3d.com/learn/tutorials/topics/graphics/ambient-lighting" data-href="https://unity3d.com/learn/tutorials/topics/graphics/ambient-lighting" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ambient lighting</a> is light that the object emits if there are no other lights, this is like the base color or shape from your current viewpoint. <a href="http://learnwebgl.brown37.net/09_lights/lights_diffuse.html" data-href="http://learnwebgl.brown37.net/09_lights/lights_diffuse.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Diffuse lighting</a> is light that the object emits evenly in all directions from the point where a light ray hits it, things that have a high diffuse reflectance would be objects with a matte finish.</p><figure name="32a7" id="32a7" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 517px; max-height: 183px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 35.4%;"></div><img class="graf-image" data-image-id="1*5xxWfZ28CuXW0ULmPRTWxw.png" data-width="517" data-height="183" src="img/1_5xxWfZ28CuXW0ULmPRTWxw.png"></div><figcaption class="imageCaption">Diffuse lighting reflects the light ray in all directions from the point of contact.</figcaption></figure><p name="2c51" id="2c51" class="graf graf--p graf-after--figure">The ambient light is just a multiplication of two constant values, the <em class="markup--em markup--p-em">Light_ambient</em> value (the amount of ambient light in our virtual environment) and the <em class="markup--em markup--p-em">Material_ambient</em> value (a value that represents the material’s sensitivity to reflect ambient light).</p><p name="b651" id="b651" class="graf graf--p graf-after--p">In this tutorial we also introduce the concept of phong shading (for the diffuse light). This method of shading takes the position of a light vector, and the normal for the fragment we are trying to shade and calculates the dot product, dot(normal_vector, light_vector). The result is used as a weight to multiply the diffuse light value by. The dot product calculates the component of the original light ray that lies along normal, in other words, how much light the normal/this vertex should reflect. We actually do all this in the vertex shader (using a Vertex_normal that we pass in for each vertex), add all these light values into the color (a varying value), then interpolate the results in the fragment shader.</p><p name="b774" id="b774" class="graf graf--p graf-after--p"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial5.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial5.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial5.py</a></p><h4 name="f7bc" id="f7bc" class="graf graf--h4 graf-after--p">Tutorial 6</h4><p name="2bd5" id="2bd5" class="graf graf--p graf-after--h4">This tutorial introduces several new concepts. The first is indexed rendering, this is fairly simple, instead of defining points in order of rendering. We define a set of points; the order in which we use them is just a list of numbers (index into the set of points) that tells us which point to use. We use the Sphere function from scenegraph.basenodes to generate the vertices and the index into those vertices. The benefit of this is we can store only the information we need and avoid storing redundant vertices (when you get more complex structures with lots of repeated vertex use the performance is a lot better). We also use something called <a href="https://paroj.github.io/gltut/Illumination/Tut11%20BlinnPhong%20Model.html" data-href="https://paroj.github.io/gltut/Illumination/Tut11%20BlinnPhong%20Model.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">blinn-phong</a> shading, a simplified version of phong shading, for <a href="https://en.wikipedia.org/wiki/Specular_reflection" data-href="https://en.wikipedia.org/wiki/Specular_reflection" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">specular light reflections</a>. <a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model" data-href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Blinn</a> shading takes a half light vector, a vector that points out at an angle that is one half the angle between the light source and our viewpoint. The reason for doing this is because for specular light we need to take the dot product of the reflected light vector and the view vector. Often though the angle between our view and our reflected light is bigger than 90 degrees. This makes the phong caculation (dot product, cos(x&gt;90)) difficult to work with (negative values). So blinn figured out that taking the dot product between the half light vector and the normal vector works and returns a viable weight (amount of reflection) for specular light. Imagine you are moving along a wireframe pixel by pixel calculating which light values each pixel should reflect. In tutorial 6 this is very much the case as our phong calculation is in the fragment shader, which means it’s run for every pixel in the fragment. Well if you have to take the dot product between the reflected specular light (changes for every pixel) and the angle of view (doesn’t change)this is going to change for every pixel. Every pixel reflects some different vector. The half light vector between your view (which doesn’t change) and the light source (whose vector doesn’t change) is a constant. So using the blinn model is actually cheaper computationally for specular lighting.</p><p name="244d" id="244d" class="graf graf--p graf-after--p">This photo demonstrates ambient + diffuse + specular lighting using blinn-phong shading very well:</p><figure name="7a96" id="7a96" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 195px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 27.800000000000004%;"></div><img class="graf-image" data-image-id="1*iB13DKh3nMh2gIoiwP2Mzg.png" data-width="963" data-height="268" src="img/1_iB13DKh3nMh2gIoiwP2Mzg.png"></div></figure><p name="358d" id="358d" class="graf graf--p graf-after--figure"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial6.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial6.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial6.py</a></p><h4 name="8468" id="8468" class="graf graf--h4 graf-after--p">How to think about light rays, reflections, normals, and our viewpoint.</h4><p name="18e4" id="18e4" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">V </em>is the view vector that represents our viewpoint. <em class="markup--em markup--p-em">N</em> is the normal, the vector that is predefined and that points out of this fragment. <em class="markup--em markup--p-em">L</em> is the ray from the light source. <em class="markup--em markup--p-em">R</em> is the specular reflected ray from the light source. <em class="markup--em markup--p-em">H</em> is the ‘half light vector’ for calculating blinn shading (vector between <em class="markup--em markup--p-em">V</em> and <em class="markup--em markup--p-em">L</em>). Something you will notice about all these vectors is that: 1-they point outward, 2-they all originate at a single point, 3-the vectors have the same length. All the vectors point outwards to make calculating dot products easier (counter intuitive for <em class="markup--em markup--p-em">V</em> and <em class="markup--em markup--p-em">L</em>). All the vectors originate at a single point or vertex, that is how our data is defined and it makes it possible to calculate light in the vertex shader. We call <em class="markup--em markup--p-em">normalize</em> on the vectors before doing dot products, this gets our vectors in the same length, we do this because we only care about the directions of the light and viewpoint for calculating the weightings in these exercises, not the magnitude.</p><figure name="9279" id="9279" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 477px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 68.2%;"></div><img class="graf-image" data-image-id="1*ZhwZcMgTeVWWJEaDLt8weg.png" data-width="1100" data-height="750" data-is-featured="true" src="img/1_ZhwZcMgTeVWWJEaDLt8weg.png"></div></figure><h4 name="f142" id="f142" class="graf graf--h4 graf-after--figure">Tutorial 7</h4><p name="9d9f" id="9d9f" class="graf graf--p graf-after--h4">The purpose of this tutorial is to do a little code cleanup and show an example of what using multiple lights looks like. One thing we did was move material properties (i.e. ambient material, diffuse, specular reflectance vales) into a structure instead of just setting them as global uniform values. We also setup 3 lights; for each light we provide ambient, diffuse, specular, and position vectors each with size 4. We show how to store these lights and their component vectors in a special array and populate this array with <em class="markup--em markup--p-em">glUniform4fv</em>. If you do tutorial 7 correctly you should get:</p><figure name="91b5" id="91b5" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 301px; max-height: 329px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 109.3%;"></div><img class="graf-image" data-image-id="1*3FJucAcOGgj5u9pNLdR3eA.png" data-width="301" data-height="329" src="img/1_3FJucAcOGgj5u9pNLdR3eA.png"></div></figure><p name="87a3" id="87a3" class="graf graf--p graf-after--figure"><a href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial7.py" data-href="https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial7.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/yvan/nbsblogs/blob/master/pyopengl_tut/tutorial7.py</a></p><p name="462c" id="462c" class="graf graf--p graf-after--p">In the guide the code says to take any dot products of the normal, reflected light vectors that are greater than -0.05 and only calculate the specular component for those. I’m not sure what this does because if we remove the if statement the result is quite similar. Also taking the max of 0 and anything should always be 0 at the lowest so why make the threshold -0.05? I’m going to investigate</p><h4 name="741c" id="741c" class="graf graf--h4 graf-after--p">Investigation as to why the cutoff produces a smooth effect</h4><p name="c054" id="c054" class="graf graf--p graf-after--h4">At first I thought the code for making specular reflection in tutorials 6,7 was simple but I realize there is some level of subtlety to it. We are going to run the tutorial 6 phong_weightCalc function:</p><figure name="48c3" id="48c3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yvan/152004d81d1aab30a566879337211a3a.js"></script></figure><p name="8003" id="8003" class="graf graf--p graf-after--figure">If we leave the threshold at -0.05 we get a result:</p><pre name="21bd" id="21bd" class="graf graf--pre graf-after--p">if (n_dot_pos &gt; -0.05)</pre><figure name="fcd9" id="fcd9" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 301px; max-height: 327px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.60000000000001%;"></div><img class="graf-image" data-image-id="1*VOTqHYmx4ZDDf_PO6Y02lA.png" data-width="301" data-height="327" src="img/1_VOTqHYmx4ZDDf_PO6Y02lA.png"></div><figcaption class="imageCaption">Figure 1</figcaption></figure><p name="3d44" id="3d44" class="graf graf--p graf-after--figure">If we change the threshold to a hard 0.0 in the if statement we get this:</p><pre name="0088" id="0088" class="graf graf--pre graf-after--p">if (n_dot_pos &gt; -0.05)<br>---&gt;<br>if (n_dot_pos &gt; 0.0)</pre><figure name="bb5e" id="bb5e" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 301px; max-height: 327px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.60000000000001%;"></div><img class="graf-image" data-image-id="1*Dm1P48ljoojcmcmOkYH1sQ.png" data-width="301" data-height="327" src="img/1_Dm1P48ljoojcmcmOkYH1sQ.png"></div><figcaption class="imageCaption">Figure 2</figcaption></figure><p name="9ef8" id="9ef8" class="graf graf--p graf-after--figure">It is a weird cut off sphere. The cutoff actually doesn’t make sense. In theory even the parts that are not hit by the specular light should be illuminated via ambient light, we should still see something on the dark side? Ok so I just tested increasing the ambient light and a faint outline does show up on the dark side (Figure 3):</p><pre name="953e" id="953e" class="graf graf--pre graf-after--p">glUniform4f( self.Light_ambient_loc, .1,.1,.1, 1.0 )<br>--&gt;<br>glUniform4f( self.Light_ambient_loc, 1.0,1.0,1.0, 1.0 )</pre><figure name="8eee" id="8eee" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 301px; max-height: 327px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.60000000000001%;"></div><img class="graf-image" data-image-id="1*-F6qgv0nEPGZn-8sFLxM8A.png" data-width="301" data-height="327" src="img/1_-F6qgv0nEPGZn-8sFLxM8A.png"></div><figcaption class="imageCaption">Figure 3</figcaption></figure><p name="a1cc" id="a1cc" class="graf graf--p graf-after--figure">I will leave the ambient light like this as it makes things more visible/comparable. The thing that is a bit weird is that this if statement always fires when the threshold is set at -0.05. I know because if we remove the if statement we get an output like Figure 1 again; so it is like the if statement does not matter. This make sense, we maxed <em class="markup--em markup--p-em">n_dot_pos</em> with 0 meaning any negative result of the dot product would default to 0. Lets see what specular light is reflected for just the dot products that are 0.0:</p><pre name="4bf8" id="4bf8" class="graf graf--pre graf-after--p">if (n_dot_pos == 0.0)</pre><figure name="441e" id="441e" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 301px; max-height: 326px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.3%;"></div><img class="graf-image" data-image-id="1*vRVv5jy7iRUm2gwTGHyv5w.png" data-width="301" data-height="326" src="img/1_vRVv5jy7iRUm2gwTGHyv5w.png"></div><figcaption class="imageCaption">Figure 4</figcaption></figure><p name="8476" id="8476" class="graf graf--p graf-after--figure">Ok so even when our light source is perfectly perpendicular to the normals it still produces a small band of green light for the specular reflection. Let’s max the dot product with -0.05 and set the threshold for n_dot_pos back to &gt; -0.05 and also try ≥ -0.05 to see if this makes a difference:</p><pre name="94f3" id="94f3" class="graf graf--pre graf-after--p">float n_dot_pos = max(-0.05, dot(frag_normal, light_pos));</pre></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="fe64" id="fe64" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--pre" style="width: 50%;"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.3%;"></div><img class="graf-image" data-image-id="1*yTyroebs5ysI0M3Pzia-KQ.png" data-width="301" data-height="326" src="img/1_yTyroebs5ysI0M3Pzia-KQ.png"></div></figure><figure name="08b0" id="08b0" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 50%;"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.3%;"></div><img class="graf-image" data-image-id="1*7HmYhnIL2hngba2BCjt3hA.png" data-width="301" data-height="326" src="img/1_7HmYhnIL2hngba2BCjt3hA.png"></div><figcaption class="imageCaption" style="width: 200%; left: -100%;">n_dot_pos ≥-0.05, &gt; -0.05, and the original figure 1 sphere respectively</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="51ff" id="51ff" class="graf graf--p graf-after--figure">This makes sense all the dot products that are very negative get set to -0.05 and are included in the specular lighting so we get a bigger green reflection on the sphere on the left. It is bigger and still doesn’t include all the surface (we still see some ambient peeking out from behind) because when we take the dot product of the half_light vector and our view vector (after checking the n_dot_pos) some results will still be 0, showing only ambient light and no specular light. In the right image all these negative values get set to -0.05 and aren’t included by the &gt; comparator and thus we get a more brutal cutoff. In conclusion: if you want a smoother cutoff for your specular light you need to max by and make sure that value is included in your comparator. So the original works but only because 0.0 is always &gt; -0.05. You might as well use this function (which i’ve added to my tutorial 7 code):</p><figure name="1478" id="1478" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/yvan/5835c68d5b62f325dbdddada13f01088.js"></script></figure><h4 name="71ad" id="71ad" class="graf graf--h4 graf-after--figure">General Notes:</h4><p name="8a59" id="8a59" class="graf graf--p graf-after--h4">I have added annotations for the first 7 tutorials as you can see there are many more in the <a href="http://pyopengl.sourceforge.net/context/tutorials/index.html" data-href="http://pyopengl.sourceforge.net/context/tutorials/index.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">opengl tutorial page</a>. Feel free to do them!</p><p name="9fa3" id="9fa3" class="graf graf--p graf-after--p">You may notice a lot of calls to the <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/normalize.xhtml" data-href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/normalize.xhtml" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">normalize function</a> in our opengl shader code; this just gets our vectors converted to unit vectors pointing in the same direction. We just want the directions of a lot of vectors and don’t care about magnitude.</p><p name="6f66" id="6f66" class="graf graf--p graf-after--p">It’s really easy to misspell something like <code class="markup--code markup--p-code">glVertexAttribArray</code> and then your program will run but won’t render and may fail silently. I’m not sure if this is a result of the <code class="markup--code markup--p-code">OpenGLContext</code>but it happens. To prevent this be careful when typing out the names of things.</p><p name="83f5" id="83f5" class="graf graf--p graf-after--p">Dot products are |A| * |B| * cos(ø) where ø is the angle between vectors A and B; dot products are scalar. The dot product is always zero when two vectors are at a 90º angle to each other because cos(90º) = 0. <a href="https://www.mathsisfun.com/algebra/vectors-dot-product.html" data-href="https://www.mathsisfun.com/algebra/vectors-dot-product.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">This is a great explanation on mathisfun</a>.</p><h4 name="1aa1" id="1aa1" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="59e3" id="59e3" class="graf graf--p graf-after--h4">Shaders are really cool. If you’re interested in blogs like the one I just wrote you can sign up for my newsletter <a href="https://tinyletter.com/generationmachine" data-href="https://tinyletter.com/generationmachine" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">Generation Machine</em></a> where I tend to keep readers up to date on the stuff I write. You can also checkout my <a href="https://towardsdatascience.com/clpr-a-3d-dataset-for-learning-pose-and-rotation-44a39e0a528a" data-href="https://towardsdatascience.com/clpr-a-3d-dataset-for-learning-pose-and-rotation-44a39e0a528a" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous post</a> where I used pygame to generate a dataset of 3D cubes. Also I want to leave a final note here. It could be something I’ve said above is wrong, as always; enjoy your day.</p><h4 name="dd2f" id="dd2f" class="graf graf--h4 graf-after--p">Some other resources:</h4><p name="a99a" id="a99a" class="graf graf--p graf-after--h4"><a href="https://www.labri.fr/perso/nrougier/python-opengl/#python-opengl-for-scientific-visualization" data-href="https://www.labri.fr/perso/nrougier/python-opengl/#python-opengl-for-scientific-visualization" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.labri.fr/perso/nrougier/python-opengl/#python-opengl-for-scientific-visualization</a> (a really cool book by nicolas rougier on python + opengl, this book seems very high quality and i’ve been using it as a reference)</p><p name="3892" id="3892" class="graf graf--p graf-after--p"><a href="https://thebookofshaders.com" data-href="https://thebookofshaders.com" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://thebookofshaders.com</a> + <a href="https://www.shadertoy.com" data-href="https://www.shadertoy.com" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://www.shadertoy.com</a> (pretty sure you can use anything with openGL 2+ (in the s<a href="https://itunes.apple.com/us/app/shadertoy/id717961814?mt=8" data-href="https://itunes.apple.com/us/app/shadertoy/id717961814?mt=8" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">hadertoy app</a>), webGL online, here).</p><p name="9f1d" id="9f1d" class="graf graf--p graf-after--p"><a href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" data-href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html</a> (webgl fundamentals)</p><p name="c17d" id="c17d" class="graf graf--p graf-after--p"><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules" data-href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules</a>(guide to using Vulkan)</p><p name="9e43" id="9e43" class="graf graf--p graf-after--p"><a href="https://github.com/realitix/vulkan" data-href="https://github.com/realitix/vulkan" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/realitix/vulkan</a> (python vulkan bindings, so you can use Vulkan in python)</p><p name="591f" id="591f" class="graf graf--p graf-after--p"><a href="https://github.com/mackst/vulkan-tutorial" data-href="https://github.com/mackst/vulkan-tutorial" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/mackst/vulkan-tutorial</a> (python vulkan tutorial)</p><p name="9aac" id="9aac" class="graf graf--p graf-after--p graf--trailing"><a href="https://www.opengl.org/archives/resources/features/KilgardTechniques/oglpitfall/" data-href="https://www.opengl.org/archives/resources/features/KilgardTechniques/oglpitfall/" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://www.opengl.org/archives/resources/features/KilgardTechniques/oglpitfall/</a> (common pitfalls using opengl)</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@yvanscher" class="p-author h-card">Yvan Scher</a> on <a href="https://medium.com/p/c19a1376eda1"><time class="dt-published" datetime="2018-07-26T00:24:33.495Z">July 26, 2018</time></a>.</p><p><a href="https://medium.com/@yvanscher/an-introduction-to-shaders-in-opengl-c19a1376eda1" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on June 23, 2020.</p></footer></article></body></html>
